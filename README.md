### В этом проекте используется несколько интересных решений:
 - [Нестандартная архитектура](app/Common)
   - Все основные файлы фреймворка вынесены в `/app/Common/Framework`
   - Общие абстрактные классы/контракты или хелперы находятся в `/app/Common`
   - Папки в app за исключением Common делятся на сущности, например `/app/Car` или `/app/User`
 - [Динамические ресурсы](app/Common/Http/Resources), если в обычном проекте нужно делать `return CarResource::collection($cars)` то тут можно вернуть `return new ResponseResource($cars)`
   - Это дает стандартизацию ответов
   - Если $cars - это `PaginatorAbstract` то в таком случае автоматически прокинется информация о `current_page`, `last_page`, `limit`, `total`
   - Если у Car есть relation, то он также будет завернут в свой ресурс, например Car->user будет завернут в UserResource.
 - [Архитектура драйверов](app/Car)
   - В `app/Car/` есть папки `Drivers` и `DriversCommon`, в них логика модульных фич. У каждой фичи есть контракт и описание
   - У каждого драйвера свой набор фич
   - Все фичи по умолчанию должны вызываться в CarDriverOrchestrator, в нем менеджмент фичами. Например у драйвера может быть фича `OpenDoor` и `OpenDoors`, в зависимости от зависимого API. В таком случае в DriverOrchestrator у нас есть функция `openDoors(array $doorNumbers)` и внутри проверка на сущестование фичей.


### TODO list:
 - Дописать CarDriverOrchestrator для текущих фич
 - Дописать borrow/release для Car
   - Использовать Semaphore
   - Использовать DB::transaction
   - Юзер может вызывать фичи только если он занял машину
   - Список машин юзера
   - Проверка занятых юзером машин
 - Добавить ещё пару фич для демонстрации, например ApiFeature
 - Сделать Unit тесты
 - Добавить Actions и демки для них
